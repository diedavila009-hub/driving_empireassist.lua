<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Driving Empire - Advanced Physics Analyzer</title>
    <style>
        :root {
            --bg: #0a0c14; --panel: #161a2e; --text: #f0f0f5;
            --accent: #00ff88; --danger: #ff4d4d; --info: #00d9ff; --gold: #ffd700;
        }
        body { font-family: 'Segoe UI', Tahoma, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 20px; overflow-x: hidden; }
        .dashboard { display: grid; grid-template-columns: 360px 1fr; gap: 20px; }
        .panel { background: var(--panel); border-radius: 12px; padding: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); border: 1px solid #2a304d; }
        h2 { margin-top: 0; font-size: 18px; color: var(--info); text-transform: uppercase; letter-spacing: 1px; }
        textarea { 
            width: 100%; background: #05070a; color: #50fa7b; border: 1px solid #333; 
            padding: 10px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 11px; resize: none;
        }
        canvas { background: #05070a; border-radius: 8px; width: 100%; image-rendering: crisp-edges; }
        .stat-card { background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid var(--info); }
        .stat-card b { display: block; font-size: 10px; color: #888; text-transform: uppercase; }
        .stat-card span { font-size: 20px; font-weight: bold; font-family: 'Orbitron', sans-serif; }
        .btn { 
            width: 100%; padding: 12px; border: none; border-radius: 6px; font-weight: bold; 
            cursor: pointer; transition: 0.3s; margin-top: 10px;
        }
        .btn-primary { background: var(--info); color: #000; }
        .btn-primary:hover { background: #fff; }
        .legend { font-size: 11px; display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 15px; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; }
    </style>
</head>
<body>

<div class="dashboard">
    <div class="panel">
        <h2>Telemetría Pro</h2>
        <textarea id="jsonInput" rows="12" placeholder="Pega los datos de Roblox aquí..."></textarea>
        <button id="btnProcess" class="btn btn-primary">ANALIZAR DATOS</button>
        
        <div style="margin-top: 20px;">
            <div class="stat-card"><b>Velocidad Máxima</b><span id="stMaxSpd">0</span> km/h</div>
            <div class="stat-card" style="border-color: var(--danger)"><b>Impactos Detectados</b><span id="stColls">0</span></div>
            <div class="stat-card" style="border-color: var(--gold)"><b>Tiempo en Aire (Airtime)</b><span id="stAir">0.00</span>s</div>
            <div class="stat-card"><b>Distancia de Carrera</b><span id="stDist">0.00</span> km</div>
        </div>

        <div class="legend">
            <div class="legend-item"><div class="dot" style="background:var(--info)"></div> Trayectoria</div>
            <div class="legend-item"><div class="dot" style="background:var(--accent)"></div> Frenada Pro</div>
            <div class="legend-item"><div class="dot" style="background:var(--danger)"></div> Choque/Giro</div>
            <div class="legend-item"><div class="dot" style="background:white"></div> Impacto Duro</div>
        </div>
    </div>

    <div class="panel">
        <h2>Mapa de Física del Circuito</h2>
        <canvas id="trackCanvas" width="900" height="550"></canvas>
        <h2 style="margin-top:20px;">Curva de Velocidad y Fuerzas G</h2>
        <canvas id="speedCanvas" width="900" height="150"></canvas>
    </div>
</div>

<script>
    const trackCanvas = document.getElementById('trackCanvas');
    const speedCanvas = document.getElementById('speedCanvas');
    const tCtx = trackCanvas.getContext('2d');
    const sCtx = speedCanvas.getContext('2d');

    // --- REPARACIÓN AVANZADA ---
    function deepRepair(text) {
        let clean = text.trim();
        // Cortar basura final tipo "po" o "del"
        const lastBrace = clean.lastIndexOf('}');
        if (lastBrace !== -1) clean = clean.substring(0, lastBrace + 1);

        // Intento de parseo por bloques (Regex) para ser inmune a cortes
        const matches = clean.match(/\{"headingErrorDeg".*?\}/g);
        if (matches) {
            return matches.map(m => {
                try { return JSON.parse(m + (m.endsWith('}') ? '' : '}')); } 
                catch(e) { return null; }
            }).filter(x => x !== null);
        }
        return [];
    }

    document.getElementById('btnProcess').onclick = () => {
        const raw = document.getElementById('jsonInput').value;
        const samples = deepRepair(raw);
        if (!samples.length) return alert("Datos no reconocidos o muy corruptos.");

        tCtx.clearRect(0,0,trackCanvas.width,trackCanvas.height);
        sCtx.clearRect(0,0,speedCanvas.width,speedCanvas.height);

        // Configuración de límites y escalas
        const xs = samples.map(s => s.pos.x), zs = samples.map(s => s.pos.z);
        const minX = Math.min(...xs), maxX = Math.max(...xs);
        const minZ = Math.min(...zs), maxZ = Math.max(...zs);
        const scale = Math.min((trackCanvas.width-100)/(maxX-minX || 1), (trackCanvas.height-100)/(maxZ-minZ || 1));

        const getX = (x) => (x - minX) * scale + 50;
        const getZ = (z) => (z - minZ) * scale + 50;

        let maxKmh = 0, totalDist = 0, crashes = 0, airtime = 0;

        // --- DIBUJO DE TRAYECTORIA Y FÍSICA ---
        samples.forEach((s, i) => {
            const kmh = s.speed * 3.6;
            if (kmh > maxKmh) maxKmh = kmh;

            if (i > 0) {
                const prev = samples[i-1];
                
                // 1. Calcular distancia (km)
                totalDist += Math.sqrt(Math.pow(s.pos.x-prev.pos.x,2) + Math.pow(s.pos.z-prev.pos.z,2));

                // 2. Detectar Airtime (Salto en eje Y)
                if (Math.abs(s.pos.y - prev.pos.y) > 0.5 && s.speed > 5) {
                    airtime += (s.time - prev.time);
                }

                // 3. Dibujar línea base
                tCtx.beginPath();
                tCtx.strokeStyle = "rgba(0, 217, 255, 0.3)";
                tCtx.lineWidth = 2;
                tCtx.moveTo(getX(prev.pos.x), getZ(prev.pos.z));
                tCtx.lineTo(getX(s.pos.x), getZ(s.pos.z));
                tCtx.stroke();

                // 4. Lógica de frenado Pro vs Derrape
                if (s.deltaV > 1.5) { // Está perdiendo velocidad
                    const isDrifting = Math.abs(s.headingErrorDeg) > 15 || Math.abs(s.lateralSpeed) > 3;
                    tCtx.fillStyle = isDrifting ? "var(--danger)" : "var(--accent)";
                    tCtx.beginPath();
                    tCtx.arc(getX(s.pos.x), getZ(s.pos.z), 4, 0, Math.PI*2);
                    tCtx.fill();
                }

                // 5. Marcador de colisión (Impacto duro)
                if (s.collision) {
                    crashes++;
                    tCtx.strokeStyle = "white";
                    tCtx.lineWidth = 3;
                    const cx = getX(s.pos.x), cz = getZ(s.pos.z);
                    tCtx.beginPath();
                    tCtx.moveTo(cx-12, cz-12); tCtx.lineTo(cx+12, cz+12);
                    tCtx.moveTo(cx+12, cz-12); tCtx.lineTo(cx-12, cz+12);
                    tCtx.stroke();
                }
            }
        });

        // Gráfico de Velocidad simplificado
        sCtx.beginPath();
        sCtx.strokeStyle = "var(--accent)";
        samples.forEach((s, i) => {
            const x = (i / samples.length) * speedCanvas.width;
            const y = speedCanvas.height - (s.speed * 3.6 / maxKmh * speedCanvas.height);
            if(i===0) sCtx.moveTo(x,y); else sCtx.lineTo(x,y);
        });
        sCtx.stroke();

        // Actualizar UI
        document.getElementById('stMaxSpd').innerText = Math.round(maxKmh);
        document.getElementById('stColls').innerText = crashes;
        document.getElementById('stDist').innerText = (totalDist / 1000).toFixed(3);
        document.getElementById('stAir').innerText = airtime.toFixed(2);
    };
</script>
</body>
</html>
